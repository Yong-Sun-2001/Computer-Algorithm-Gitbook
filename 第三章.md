<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

# 动态规划

## 重点

- 动态规划算法的两个基本要素：最优子结构性质、重叠子问题性质
- 典型问题：矩阵连乘、最长公共子序列、0-1背包问题、最大子段和、流水作业调度（Johnson调度法则）等等



## 内容

### 动态规划基本步骤

- 1、找出最优解的性质，并刻画其结构特征 
- 2、递归地定义最优值（写出动态规划方程） 
- 3、以自底向上（或自顶向下）的方式计算出最优值 
- 4、根据计算最优值时得到的信息，构造一个最优解 【可选】

### 最优子结构性质

- 当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质
- 证明：反证法：先假设由问题的最优解导出的子问 题的解不是最优的，然后再设法证明在这个假 设下可构造出一个比原问题最优解更好的解， 从而导致矛盾

### 重叠子问题性质

- 在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质。

### 动态规划与分治的区别

- 独立性：分治法各子问题互相独立，动态规划法 的各子问题可不独立
- 子问题数目：动态规划法中涉及的子问题，不独立的有很多，而独立的应只有多项式级;分治法涉及的子问题数一般达指数级
- 动态规划法把问题分成许多子问题，每个子问题的解都是局部最优；分治法未必考虑最优性
- 动态规划法可用备忘录方法

### 矩阵连乘问题


  - 时间复杂度O($$N^3$$)、空间复杂度O($$N^2$$)

  ![image-20211114091435211](images\image-20211114091435211.png)

  ![image-20211114103511755](images\image-20211114103511755.png)

  ![image-20211114103428195](images\image-20211114103428195.png)

### 单侧跳马问题

![image-20211114104738552](images\image-20211114104738552.png)

### 复制书稿问题

![image-20211114105256725](images\image-20211114105256725.png)

### 凸多边形最优三角划分问题


- 给定凸多边形P，以及定 义在由多边形的边和弦组成的三角形上的权函数w。 要求确定该凸多边形的三角剖分，使得该三角剖 分中诸三角形上权之和为最小。【思想：类似于矩阵连乘】

![image-20211114105607062](\images\image-20211114105607062.png)

![image-20211114105752300](images\image-20211114105752300.png)

### 最长公共子序列问题


  - 给定2个序列X={x1,x2,…,xm}和 Y={y1,y2,…,yn}，找出X和Y的最长公共子序列 Z

  ![image-20211114110116219](\images\image-20211114110116219.png)

  ```C++
  lcsLength(x,y,b){
  m=x.length-1; n=y.length-1;
  for(i=1;i<=m;i++)
  c[i][0]=0; //j=0,规模最小，第1式
  for(j=1;j<=n;i++)
  c[0][j]=0; //i=0,规模最小，第1式
  for (int i = 1; i <= m; i++)
  for (int j = 1; j <= n; j++) 
  if (x[i]==y[j]) {
  c[i][j]=c[i-1][j-1]+1;
  b[i][j]=‘1’;} //第2式
  else if (c[i-1][j]>=c[i][j-1]) 
  { c[i][j]=c[i-1][j];
  b[i][j]=‘2’;} //第3式
  else 
  { c[i][j]=c[i][j-1];
  b[i][j]=‘3’;} //第3式
   }
  //O（mn）
  ```

### 银币问题


  - n块银币C1、C2、C3、…、Cn中有一块不合格， 较轻，用天平找出这块不合格的银币，问天平要 称量多少次，如何称？
  - Tn为**最坏情况**下秤n个银币的最少次数

![image-20211114112108246](images\image-20211114112108246.png)

### 最大子段和问题

- ###### 给定由n个整数组成的序列$$a_1 , a_2 , a_3 ,\cdots,  a_n$$ , 求该序列形如$$\sum{a_k}$$的子段和的最大值。

- ![image-20211114114021830](images\image-20211114114021830.png)

```C++
int MaxSum(int n, int *a)
{
int s = 0, b = 0;
for (int i = 1;i <= n;i ++ ) {
if (b > 0) b += a[i];
else b = a[i];
if (b > sum) sum = b;
}
return sum;
}
```

- 拓展问题：最大m子段和问题、最大子矩阵和问题【总复杂性O($$m^2n$$)】

```c++
//最大子矩阵和问题，固定行，记b[j]表示j列上从i1行到i2行的元素之和，显然t(i1,i2)是求b[1..n]的最大子段和
int MaxSum2(int m, int n, int **a){
int sum = 0, *b = new int [n + 1];
for (int i = 1;i <= m;i ++) {
for (int k = 1;k <= n;k ++)
b[k] = a[i][k]; //初始化
for (int j = i+ l;j <= m;j ++){
for (int k = l;k <= n;k ++) b[k] + = a[i1[k];
int max = MaxSum(n,b);
if (max > sum) sum = max;
}
}
return sum;
}
```

### 流水作业调度问题

- n个作业{1，2，…，n}要在由2台机器M1和M2 组成的流水线上完成加工。每个作业加工的顺序都是先在 M1上加工，然后在M2上加工。M1和M2加工作业i所需的时 间分别为ai和bi。

- 设机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间 t 后才可利用,完成S中作业所需的最短时间记为**T(S,t)**。

- 全部作业集合N的流水作业调度问题变为：求 最优值为T(N,0)

- T(J,0)=$$a_{\pi(1)}+T({J-J_{\pi(1)},b_{\pi{(1)}}})$$【π：最优策略的工作顺序】

- <img src="images\image-20211116152705808.png" alt="image-20211116152705808" style="zoom:67%;" />

- Johnson不等式：如果作业Ji和Jj满足min{aj,bi}≥min{ai,bj}，则称 作业Ji和Jj满足Johnson不等式

- 当作业i和j满足Johnson不等式时，作业Ji 排在作业Jj的前面的加工时间小于等于（不超过）作业Jj排在作业Ji的加工时间

- 对于流水作业调度问题，必存在最优调度π ， 使得作业$$J_{\pi(i)}$$和$$J_{\pi(i+1)}$$满足Johnson不等式。

- <img src="images\image-20211116153202427.png" alt="image-20211116153202427" style="zoom:67%;" />

- ### 0-1背包问题

  - <img src="images\image-20211116153720033.png" alt="image-20211116153720033" style="zoom:67%;" />

  - ```C++
    #define jmax 100
    #define nmax 100
    float m[nmax][jmax];
    void Knapsack(float p[],int w[],int c,int n){
    int j=0,i=0; for(j=0;j<jmax;j++) m[n][j]=0; //此处为边界，表示不拿最后物品
    for(j=w[n];j<=c;j++) m[n][j]=v[n];   //此处为边界，表示拿最后一个物品
    for(i=n-1;i>1;i--){   //倒着遍历
        for(j=0;j<jmax;j++) m[i][j]=m[i+1][j];
    		for(j=w[i];j<=c;j++)
    			m[i][j]=(m[i+1][j]>(m[i+1][j-w[i]]+v[i]))?m[i+1][j]:(m[i+1][j-w[i]]+v[i]); 
    }
    m[1][c]=m[2][c];
    if(c>=w[1])
    	m[1][c]=(m[1][c]>(m[2][c-w[1]]+v[1]))?m[1][c]:(m[2][c-w[1]]+v[1]);
    }
    ```

  - 复杂度O(nc)

