# 回溯法

- 解空间树：排列/子集树
- 剪枝：约束/限界
- 算法时间复杂度影响因素：约束/限界函数复杂度、满足约束的个数

### 回溯法的算法框架

- 步骤
  
  - (1)针对所给问题，定义问题的解空间； 
  - (2)确定合适的解空间结构；
  -  (3)以深度优先方式搜索解空间，并在搜索过程 中用剪枝函数避免无效搜索，直到找到所求的 解或解空间中已无活结点时为止。
  
- 约束条件
  
  - 显式约束：对分量xi的取值的明显限定
  - 隐式约束：为满足问题的解而对不同分量之 间施加的约束。
  
- 搜索解空间树的两种策略
  - 深度优先方式系统搜索问题的解------回溯法
  - 广度优先方式搜索问题的解------分支-限界法

- 结点类型
  - 扩展结点：一个正在产生儿子的结点称为扩展结点
  - 活结点：一个自身已生成但其儿子还没有全部生成 的节点称做活结点
  -  死结点：一个所有儿子已经产生的结点称做死结点

- 回溯法：利用两种剪枝策略来避免生成那些实 际上不可能产生所需解的活结点，以减少问题的 计算量，避免无效搜索。
  - 约束函数：在扩展结点处剪去不满足约束的子树
  - 限界函数：剪去得不到最优解的子树

- ```c++
  //递归形式定义的回溯法
  void BACKTRACK(int t ) { //n为递归深度,t为当前深度
  if （t > n）返回;
  else
  while (存在合适的xt) 
  { 
  	if (x1,…,xt)是解
  		输出解x1,…,xt ；
  	BACKTRACK( t + 1 );
  }
  }
  ```

- ```C++
  //非递归形式的回溯法定义
  void BACKTRACK(int n) {
  int t= 1;
  while (t > 0){
  if (有xt，满足 约束C(x1,…,x t) &&限界Bound(x1,…,xt))
  { 
      if ((x1,…,xt)是问题的一个“解”)
          则 输出解(x1,…,xt)；
      else t= t + 1 //“深入 ”一步
  }
  else t= t - 1 ; // “回退”一步
  }
  }
  
  ```

  

- 子集树：O(2^n^)

- 排列数：O(n!)

### 装载问题

- 有一批共n个集装箱要装上2艘载重量分别为c1和c2 的轮船，其中集装箱i的重量为wi，装载问题要求确定是否有一个合理的装载方案可将这个集装 箱装上这2艘轮船。如果有，找出一种装载方案。
- 策略：首先将第一艘轮船尽可能装满，将剩余的集装箱装上第二艘轮船
- 子集树，O(2^n^)
- cw：是当前载重量，bestw：当前最优载重量   r：剩余集装箱的重量，**限界函数：cw+r > bestw**

### 0-1背包问题

- 子集树

- ```c++
  //计算上界，用于限界函数剪枝
  double bound(int i) {// 计算上界
  double cleft = c - cw; // 剩余容量
  double bnd = cp; // cp：当前价值
  while (i <= n && w[i] <= cleft) { 
  // 以物品单位重量价值递减序装入物品，可得到最大
  cleft -= w[i];
  bnd += p[i];
  i++;
  } 
  // 背包有空隙时，装满背包
  if (i <= n && w[i] > cleft) bnd += p[i] / w[i] * cleft;
  return bnd;
  }
  
  ```

### 批处理作业调度

- 给定n个作业的集合J={J1 ,J2 ,…,Jn }。每个作业必 须先由机器M1处理，然后由机器M2处理。作业Ji 需要机器j的处理时间为tji。对于一个确定的作业 调度，设Fji是作业i在机器j上完成处理的时间。

- 排列树，O(n!)

- ```C++
  void backtrack(int i){ 算法实现
      if (i > n) {
          for (int j = 1; j <= n; j++)
          bestx[j] = x[j]; bestf = f;
      } 
      else
          for (int j = i; j <= n; j++) {
              f1+=m[x[j]][1];   //f1表示第i个作业在M1上完成的时刻
              f2[i]=((f2[i-1]>f1)?f2[i-1]:f1) +m[x[j]][2];
              f+=f2[i];  
              if (f < bestf) { //小则更优  //限界函数
                  swap(x,i,j); //往分支走
                  backtrack(i+1);
                  swap(x,i,j); //回退
              }
              f1-=m[x[j]][1]; 
              f-=f2[i]; //回退 
      }
  }
  
  ```

  

### n后问题

- 任何2个皇后不放在同一行或同一列或同一斜线上。

- 排列树，O(n!)

- 约束函数：判断是否不放在同一行或同一列或同一斜线

- ```c++
  void N-queens(n){
      x[1]= 0; k = 1; //k为层次=皇后k，从皇后1开始，其列x[1]初始化0
      while (k > 0) { 
          x[k] = x[k] + 1; //从第1列开始为皇后找符合约束的列
          while( (x[k] <= n) &&!place(k)) //当前位置不合适
         	 	x[k]= x[k] + 1; //尝试下一个位置
          if (x[k] <= n) 
         		 if (k == n) sum++; //最后一层，找到所有皇后，得到一个解
         		 else { //k<0,找下一个皇后k+1的位置，
          	 k= k + 1; x[k]= 0 //初始化皇后k+1的列0
          	 } 
          else k --;   //回退
      } 
  }
  ```

### 最大团问题

- 全向连最大子图

- 子集树,O(n2^n^) 【每次判断是否满足约束需要O(n)】

- 约束函数：顶点i到已选入的顶点集中每一 个顶点都有边相连

- 限界函数：取cn + n – i，即有足够多的可选择顶点 使得算法有可能在右子树中找到更大的团。【cn：当前顶点数，n-i：剩余顶点数】

- ```c++
  void backtrack(int i){
  if (i > n) {// 到达叶结点
  for (int j = 1; j <= n; j++) bestx[j] = x[j];
  bestn = cn; return; }
  // 检查顶点 i 与当前团的连接
  int ok = 1;
  //计算扩展结点i的可行性约束，复杂性O(n) 
  for (int j = 1; j < i; j++) //欲扩展节点i
  if (x[j] == 1 && !a[i][j]) {//考察： i与前面的j是否相连
  ok = 0; break; } // i与前面的j不相连，舍弃i
  if (ok) {// 进入左子树
  x[i] = 1; cn++; backtrack(i + 1); cn--; }
  if (cn + n - i > bestn) {// 进入右子树
  x[i] = 0; backtrack(i + 1); }
  }
  ```

  

### 图的m着色问题

- 图的m着色问题：是否有一种着色法使G中每 条边的2个顶点着不同颜色

- <img src="images\image-20211118003901049.png" alt="image-20211118003901049" style="zoom:67%;" />

- ```c++
  void backtrack(int t)
  {
  if (t>n) {sum++;输出解}
  else
  for (int i=1;i<=m;i++) {
  x[t]=i;
  if (ok(t)) backtrack(t+1);
  }
  }
  ```